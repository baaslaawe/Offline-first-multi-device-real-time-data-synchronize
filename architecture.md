# 서론
 오프라인 상태에서 데이터 읽고 쓰기를 하며 그리고 그 데이터들이 다른 디바이스에도 똑같이 동기화 되기 위해, 어떻게 클라이언트 앱과 서버 앱이 구현되는지 알아보자.

 오프라인 우선 적으로 데이터를 저장하고 사용하려면, 항상 데이터를 클라이언트 기기에서 접근이 가능해야 하고, 이를 위해 로컬 데이터베이스를 이용한다. 그리고 다른 디바이스에서 접근을 하려면 서버에 데이터가 있어야 하기때문에 로컬에서 저장한 후 서버의 데이터베이스와 동기화가 필요하다. 일련의 과정들을 설계 해보자.

<br>

## 1. 첫번째 동기화 ( 서버 -> 로컬 )
실시간 동기화를 위해서는 서버쪽에서 클라이언트쪽으로 동기화를 해라 라는 신호를 줄 수도 있겠지만, 보통의 경우 클라이언트 앱에서 서버로 동기화 요청이 시작 될 것이다.

<br>

### 클라이언트 -> 서버 요청
가장 먼저 서버쪽에 동기화 요청을 하기전에 클라이언트에서 하나의 값이 필요하다. 현재 클라이언트 앱이 언제 동기화가 완료가 되었었는지 저장을 하고 있어야 한다. 이 값을 `sync_at` 이라는 변수를 사용하기로 하고, 이 값은 클라이언트 앱에 저장이 되어 있어야 한다. 한번도 동기화가 일어나지 않았다면 `0` 이고 `timestamp` 로 저장하기로 하자.

<br>
이제 이 `sync_at`값을 이용하여 서버로 동기화 요청을 한다. (`sync_local` 이라고 임의로 명명하였다.)
> [GET] https://host_url/sync_local?sync_at=1523098859

`parameter`로 `sync_at` 을 함께 넘겨주어 서버에게 `sync_at`이후에 추가된 데이터를 모두 달라고 요청을 한다.

<br>

### 서버
위의 `GET` 요청을 받아서 `sync_at`이후에 추가된 데이터를 준다는 것은, 데이터베이스의 `updated_at` 을 확인하여 `sync_at` 보다 큰 값들, 즉 클라이언트가 마지막 동기화가 된 시점인 `sync_at` 이후에 추가되거나 수정된 데이터를 모두 찾아서 준다는 의미이다.

<br>

### 서버 -> 클라이언트 응답
클라이언트에서 서버로 요청후 받은 응답으로 `sync_at` 이후의 수정/추가 된 데이터들이 있다. 이제 이 데이터들을 로컬 데이터베이스에 추가해주면 된다. `sync_at` 이 `0` 이었다고 가정을 하면 서버에서 받은 데이터들을 그대로 `insert` 하면 되겠다.

<br>

---

## 2. 전체 동기화
 위에서 서버에서 데이터를 받아와서 로컬에 추가를 했다면, 해당 데이터 들에는 서버의 `primary_key` 가 컬럼으로 함께 저장이 되어 있고, `primary_key` 를 `server_id` 로 명명한다. 그러면 그 이후에 클라이언트가 앱을 이용한다면 추가적인 데이터들이 생기거나, 기존의 데이터들이 수정이 될 것이다. 이때 추가가 된다면 `server_id` 가 없을 것이고, 수정이 되는것들은 `server_id` 가 있는 것 일수도 있고, 아닐 수도 있다. 

 이렇게 데이터가 추가/수정이 되면 이런 데이터들을 서버로 동기화를 시켜줘야 한다. 이때 `dirty_flag` 라는 플래그 값을 둬서 서버로 추가/수정이 된 데이터들이라는 것을 표시해준다. 그러니까 로컬디바이스에서 추가 또는 수정 될때 마다 해당 데이터의 `dirty_flag` 컬럼 값을 `true` 로 설정해 준다는 말이다.


이렇게 한 후, 클라이언트에서 동기화 되지 않은 데이터들이 몇개 추가/수정이 된후, 서버와 동기화 되는 과정을 다시 살펴 보도록 하자.

<br>

### 로컬데이터베이스 동기화 로직
첫번째 동기화에서 했던 과정으로 `sync_at` 이후의 동기화를 해야 할 데이터를 모두 받아 왔다고 생각해보자. 첫번째 동기화에서는 바로 모두 로컬 데이터베이스에 추가 해주면 되었지만, 기존의 데이터가 수정이 되었을수도 있기 때문에 해당 내용을 체크해야 한다. 

<br>

#### 1. 먼저 서버에서 받아온 데이터의 `server_id` 를 가지고 로컬 데이터베이스에 있는지 확인한다.
+ `server_id` 없다
    + 한번도 서버와 동기화 되지 않은 데이터이기 때문에 바로 로컬에 `insert` 를 한다.
+ `server_id` 있다.
    + 서버와 동기화가 한번이라도 된 데이터이기 때문에 `dirty_flag` 를 체크한다.
        + `dirty_flag` 가 `false`
            + 클라이언트에서 수정이 되지 않았다.
            + 서버의 데이터로 `update` 해준다.
        + `dirty_flag` 가 `true`
