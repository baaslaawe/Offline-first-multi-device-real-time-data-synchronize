# 서론
오프라인 상태에서 데이터 읽고 쓰기를 하며 그리고 그 데이터들이 다른 디바이스에도 똑같이 동기화 되기 위해, 어떻게 클라이언트 앱과 서버 앱이 구현되는지 알아보자.

오프라인 우선 적으로 데이터를 저장하고 사용하려면, 항상 데이터를 클라이언트 기기에서 접근이 가능해야 하고, 이를 위해 로컬 데이터베이스를 이용한다. 그리고 다른 디바이스에서 접근을 하려면 서버에 데이터가 있어야 하기때문에 로컬에서 저장한 후 서버의 데이터베이스와 동기화가 필요하다. 일련의 과정들을 설계 해보자.

<br>

## 1. 첫번째 동기화 ( 서버 -> 로컬 )
실시간 동기화를 위해서는 서버쪽에서 클라이언트쪽으로 동기화를 해라 라는 신호를 줄 수도 있겠지만, 보통의 경우 클라이언트 앱에서 서버로 동기화 요청이 시작 될 것이다.

<br>

### 클라이언트 -> 서버 요청
가장 먼저 서버쪽에 동기화 요청을 하기전에 클라이언트에서 하나의 값이 필요하다. 현재 클라이언트 앱이 언제 동기화가 완료가 되었었는지 저장을 하고 있어야 한다. 이 값을 `sync_at` 이라는 변수를 사용하기로 하고, 이 값은 클라이언트 앱에 저장이 되어 있어야 한다. 한번도 동기화가 일어나지 않았다면 `0` 이고 `timestamp` 로 저장하기로 하자.


이제 이 `sync_at`값을 이용하여 서버로 동기화 요청을 한다. (`sync_local` 이라고 임의로 명명하였다.)

> [GET] https://host_url/sync_local?sync_at=1523098859

`parameter`로 `sync_at` 을 함께 넘겨주어 서버에게 `sync_at`이후에 추가된 데이터를 모두 달라고 요청을 한다.

<br>

### 서버
위의 `GET` 요청을 받아서 `sync_at`이후에 추가된 데이터를 준다는 것은, 데이터베이스의 `updated_at` 을 확인하여 `sync_at` 보다 큰 값들, 즉 클라이언트가 마지막 동기화가 된 시점인 `sync_at` 이후에 추가되거나 수정된 데이터를 모두 찾아서 준다는 의미이다.

<br>

### 서버 -> 클라이언트 응답
클라이언트에서 서버로 요청후 받은 응답으로 `sync_at` 이후의 수정/추가 된 데이터들이 있다. 이제 이 데이터들을 로컬 데이터베이스에 추가해주면 된다. `sync_at` 이 `0` 이었다고 가정을 하면 서버에서 받은 데이터들을 그대로 `insert` 하면 되겠다.

<br>



## 2. 전체 동기화
위에서 서버에서 데이터를 받아와서 로컬에 추가를 했다면, 해당 데이터 들에는 서버의 `primary_key` 가 컬럼으로 함께 저장이 되어 있고, `primary_key` 를 `server_id` 로 명명한다. 그러면 그 이후에 클라이언트가 앱을 이용한다면 추가적인 데이터들이 생기거나, 기존의 데이터들이 수정이 될 것이다. 이때 추가가 된다면 `server_id` 가 없을 것이고, 수정이 되는것들은 `server_id` 가 있는 것 일수도 있고, 아닐 수도 있다. 

 이렇게 데이터가 추가/수정이 되면 이런 데이터들을 서버로 동기화를 시켜줘야 한다. 이때 `dirty_flag` 라는 플래그 값을 둬서 서버로 추가/수정이 된 데이터들이라는 것을 표시해준다. 그러니까 로컬디바이스에서 추가 또는 수정 될때 마다 해당 데이터의 `dirty_flag` 컬럼 값을 `true` 로 설정해 준다는 말이다.


이렇게 한 후, 클라이언트에서 동기화 되지 않은 데이터들이 몇개 추가/수정이 된후, 서버와 동기화 되는 과정을 다시 살펴 보도록 하자.

<br>

### 로컬데이터베이스 동기화 로직
첫번째 동기화에서 했던 과정으로 `sync_at` 이후의 동기화를 해야 할 데이터를 모두 받아 왔다고 생각해보자. 첫번째 동기화에서는 바로 모두 로컬 데이터베이스에 추가 해주면 되었지만, 기존의 데이터가 수정이 되었을수도 있기 때문에 해당 내용을 체크해야 한다. 


#### 먼저 서버에서 받아온 데이터의 `server_id` 를 가지고 로컬 데이터베이스에 있는지 확인한다.
+ `server_id` 없다
    + 한번도 서버와 동기화 되지 않은 데이터이기 때문에 바로 로컬에 `insert` 를 한다.

+ `server_id` 있다.
    + 서버와 동기화가 한번이라도 된 데이터이기 때문에 `dirty_flag` 를 체크한다.
        + `dirty_flag` 가 `false`
            + 클라이언트에서 수정이 되지 않았다.
            + 서버의 데이터로 클라이언트의 데이터를 `update` 해준다.
            + -> `dirty_flag`를 `false` 로 만들어 준다.
        + `dirty_flag` 가 `true`
            + 서버에서 수정이 된 데이터가 클라이언트에서도 수정되었다. -> `충돌`
            + `충돌정책`에 따라서 업데이트 하거나 둔다.
                + 서버의 것 선택 -> `dirty_flag`를 `false` 로 만들며 서버의 데이터로 `updqte`
                + 클라이언트 것 선택 -> `dirty_flag`를 `true`인채로 그대로 둔다.

<br>

### 서버쪽으로 동기화 해야할 데이터 전송
위의 과정을 거쳤다면 이제 서버에 있는 동기화해야할 데이터들을 모두 클라이언트 데이터베이스에 동기화를 한 것이다. 이제 클라이언트의 데이터들을 서버로 전송하여 동기화를 시켜야 한다.

> [POST] https://host_url/sync_server 

`sync_server`라는 api 를 만들어서 요청을 한다. `body`는 클라이언트 데이터베이스에서 `dirty_flag`가 `true`이 것들을 모두 SELECT 하여 `body`에 담아서 보내는데, 이때 `server_id`가 있는지 없는지를 체크하여 없으면 `post`에 있으면 `patch`로 묶어서 보낸다. 그리고 응답을 받으면 응답을 토대로 보냈던 데이터의 `dirty_flag`를 `false`로 바꿔주게 된다.

``` json
{
    "post": {
        "table": {
            "local_id": 2,
            "name": "moka insert.."
            ...
        },
        ...
    },
    "patch": {
        "table": {
            "local_id": 3,
            "server_id": 11,
            "name": "moka update.."
            ...
        },
        ...
    }
}
```

이때 서버에서는 `post`에 묶여서 온 데이터들은 그대로 서버 데이터베이스에 `insert`를 해주고, `patch`에 묶여 있는 데이터들은 `server_id`를 이용하여 서버 데이터베이스 에서 찾아서 `update`를 해준다. 이때 `post`에 묶여서 `insert`해준 데이터들은 `insert` 후 생긴 `server_id`를 `local_id`에 묶어서 응답을 보내주어야 한다. `patch`에 묶여서 `update`해준 데이터들은 `local_id`만 따로 묶어서 응답을 보내준다.

이렇게 `local_id`와 `server_id`를 응답으로 보내주는 이유는, 클라이언트에서 이 응답을 받아서 해당 동기화를 하기위해 서버로 보냈던 데이터들을 응답의 `local_id`로 다시 찾아와서 `dirty_flag`를 `false`로 바꿔주기 위함이다. 이렇게 클라이언트에서 서버응답을 통해 업데이트를 해주면, 모든 데이터의 `dirty_flag`가 `false`가 될 것이고, 이제 모든 데이터의 동기화가 끝난 것 이다. 이렇게 서버와 클라이언트의 데이터가 동일하게 된다.

<br>
        
## 3. 실시간 동기화
실시간 동기화를 하기 위해서는 위의 로직에 플러스로 `push` 또는 `soket` 등을 이용하여 서버쪽에서 클라이언트로 알림을 보낼수 있도록 한다. 그리고 푸쉬를 보낼 클라이언트 들의 정보를 알기위한 별도의 `session` 테이블을 만들어야 한다. 

한쪽이 동기화가 완료되었을때, 서버쪽으로 추가된 데이터가 있다면, `sessions` 에서 자기 자신을 제외한 session 을 확인하여 서버에 추가된 데이터가 있으니 동기화를 해라는 푸쉬를 보내게 된다. 그러면 그 요청들을 받은 클라이언트에서 위의 동기화 과정을 거치게 되는데, 이때는 동기화의 무한루프를 방지하기 위해 서버로 업데이트된 정보가 있더라도 다른 클라이언트 쪽으로 푸쉬를 보내지 않도록 설정을 한다.